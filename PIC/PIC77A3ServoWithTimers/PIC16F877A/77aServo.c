/* Main.c file generated by New Project wizard
 *
 * Created:   Cum Oca 15 2016
 * Processor: PIC18F4520
 * Compiler:  HI-TECH C for PIC18
 */

/*
Projede iki dc motor kullanýlýrsa TMR1 ile compare match modulünü kullanmadan TMR1 overflow interruptýný kullanarak yazacaðýz

Eðer sadece bir tane dc varsa bu program iþ görür...
CCP1 compare match modulü olarak servolar için ayrýldý...
CCP2 DC motoru sürmek için
Timer1 Servolar için...

Usart baud rate BRGH = 0 SSPBRG = 25 ( 9600 16 MHZ için... )
( Bunu RF modulüne göre deðiþtirebiliriz... )






*/



#include <htc.h>


#define false 0
#define true 1



char servo_number=0;
char dogru = false;



unsigned char seri_porttan_veri_al()
{
while( !RCIF );
return RCREG;
}
void seri_porta_veri_gonder(unsigned char jk)
 { while( !TXIF );
	 TXREG=jk;

	
	 }
void seri_portu_ayarla()
{SPBRG=25;
	BRGH=0;
	
	SPEN=1;
	
	SYNC=0;
	
	TX9=0;
	
	TXEN=1;
	
	RX9=0;
	
	CREN=1;
	
	
	/*
	RC6=1;
	
	RC7=1;
*/
	}

 volatile int temp;
volatile int temp2 = 0;


struct _servo 
{
	
	
unsigned int angle ;
	
}
bir , iki , uc;



void interrupt FNC( )
{
	GIE = 0;
	
CCP1IF = 0;	
TMR1 = 0 ;
	//Interruptlarý kapat	
	if( servo_number == 0 )
	{
		
	if( dogru ) 
	{
		dogru = false;
	
		RB4 = 0;
		

		CCPR1 = 20000;
		
		servo_number = 1;
		
		
		}
	else
	{
		RB4 = 1;
	
		
		CCPR1 = 540 + 9 * bir.angle;
	
		dogru = true;
			}
		
		
	
	}	
	else if ( servo_number == 1 )
	{
	if( dogru ) 
	{
	dogru = false;
	RB1 = 0;
	
	
		CCPR1 = 20000;
	
		servo_number = 0;
		}
	else
	{
		dogru = true;
	RB1 = 1;
		
		CCPR1 = 540 + 9 * iki.angle ;
		
		}
		
		
		
		
			

	
		
		
			
	//Interruptlarý aç...


}
	
	

CCP1IF = 0;

}

int sol= 0 , sag = 0 ;
void main(void)
 {
   // Write your code here

	TRISB = 0;

	 PORTB = 0;
	 //RB0 1.servo
	 //RB1 2.servo
	 //RB2 3.Servo...
 
	 __delay_ms( 5000 );
	 seri_portu_ayarla();
	
	 __delay_ms( 9000 );
	  __delay_ms( 9000 );
 GIE = 1;
 PEIE = 1;
//Compare mode no change on CCP1 pin ...
	 CCP1M3 = 1;
	 CCP1M2 = 0;
	 CCP1M1 = 1;
	 CCP1M0 = 1;	 
	
	CCP1IF = 0;	
	CCP1IE = 1; //Interrupt enabled...
	 
	//CCPR1 our register....
	// 10  1 /4 presc... 16 /4/4 her bir artýþ 1 us
	T1CKPS1 = 1 ;
	T1CKPS0 = 0 ; 
	CCPR1 = 20000 ;
	T1OSCEN = 0 ; //Oscillator not enabled...
	TMR1CS  = 0 ; //Internal clock FOSC/4
	
	TMR1 = 0 ;
	TMR1ON = 1 ;
	
	
	//CCP2 PWM ,çin...
	CCP2M3 = 1 ;
	CCP2M2 = 1 ;
	CCP2M1 =  0;
	CCP2M0 = 0 ;
	
	
	PR2 = 0b11111001 ; //1KHZ
T2CON = 0b00000111 ; //Presc 1/16
CCPR2L = 0b01111100 ;
CCP2CON = 0b00111100 ; //PWM modu

//10 bit resolution biz usarttan gelen bilgiyi 4 ile çarpacaðýz...
	
	TMR2ON = 0;
	
	
	
	
	
	 
#define false 0
#define true 1
	 
unsigned int angle  = 3;
char open = false;
bir.angle = 3;
iki.angle = 3;
int l ;
uc.angle = 3;
int temp;
unsigned char speed ;
unsigned char data ;
	 while (1)
	 {
	
	data =seri_porttan_veri_al () ;
		speed = seri_porttan_veri_al () ;
		if ( data == 10 ) 
		 bir.angle = speed ;
		else if ( data == 11 )
		iki.angle = speed ;
		else if ( data == 12 )
		{
		temp = speed * 4 ;
			CCP2X = temp >> 1 ;
			CCP2Y = temp ;
			CCPR2L = temp >> 2 ;
		}	
}
	 
    
 }
 
 
 
 
 
	/*for( angle = 0 ; angle < 180 ; angle += 10 )
	{
		
		bir.angle  = angle ;
		iki.angle = angle ;
	__delay_ms( 16000 );
		
		
	}
	
	for( angle = 180 ; angle > 0 ; angle -=10 )
	{
		
		bir.angle  = angle ;
	iki.angle = angle;
		__delay_ms( 16000 );
		
		
	}
	
	
	
	*/