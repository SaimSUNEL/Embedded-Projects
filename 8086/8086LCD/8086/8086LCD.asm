
;====================================================================
; Main.asm file generated by New Project wizard
;
; Processor: 8086
; Compiler:  MASM32
;
; Before starting simulation set Internal Memory Size 
; in the 8086 model properties to 0x10000
;====================================================================

include LCD.asm


DATA SEGMENT  ; data segment of the program...
PORTC47_pins db 0
index db 0
data_to_be_stored db 0
PORTA_data db 0

shift_reg_pin_to_set db 0
reg_pin_value db 0
command db 0
data_type db 0

message db "This is a try", 0
data_to_print db 0
_x db 0
_y db 0

DATA ENDS


CODE    SEGMENT PUBLIC 'CODE' 
        ASSUME CS:CODE, DS: DATA


;A16-A19 are not involved in port operations...
; first port is latched in 74hc373 (8086 first outputs port address on data/address bus)
; then this select the port to write, then 8086 sends data to 8255A


; important : data with even numbered addresses are sent over AD0-AD7, odd numbered are over AD8-AD15
; 
; A0 and A1 are connected in a specific way to make the addresses even numbered...
; that's whay Q1 and Q2 is used to select port of 8255a, 
; if it were Q0, Q1 we would use odd addreess number
; 
; Datasheet :
;Physically, the memory is organized as a high bank
;(D15–D8) and a low bank (D7–D0) of 512K 8-bit
;bytes addressed in parallel by the processor’s address lines A19–A1. Byte data with even addresses
;is transferred on the D7–D0 bus lines while odd addressed byte data (A0 HIGH) is transferred on the
;D15–D8 bus lines.
;
;
START:
	mov AX, 100h
	mov SS, AX ; set stack segment
	mov ax, 800h
	mov DS, ax
	mov ax, 0d00h
	mov es, ax
	mov sp , ax ; don't forget to set it...
	
	lea si, message
	
load_to_mem:
mov ax, 0
	mov ds, ax

	mov bl, byte ptr[si]
	cmp bl, 0
	je finish_loading

	mov ax, 800h
	mov [si], bl
	inc si
jmp load_to_mem
finish_loading:


push AX


	mov ah, 0
	mov al, 80h ; PORT A , PORT B ,PORT C 0-3 are outputs, PORTC 4-7 are inputs...
	out 06, al ; control reg  address 
	
	mov al, 0 ; clean all ports, Port A=B=C= 0
	out 0, al
	out 2, al
	out 4, al
	



	mov PORTA_data, 0h
	mov data_to_be_stored, 0h

	;mov data_to_be_stored, 10101111b
	;call LoadShiftRegister

	call LCD_init
	mov cx, 0ffh
	call delayfunction

	mov _x, 1
	mov _y, 1h
	call lcd_goto

	mov si, offset message
	call lcd_write

ENDLESS:
	
	
	mov data_to_print, 'S'
	call lcd_yaz
	

	mov cx, 2ffh
	call delayfunction
	

	
	mov cx, 2ffh
	call delayfunction
		
	JMP ENDLESS


delayfunction proc far


	COUNT2:
	mov bx, 01fh


devam2:
	dec bx

	cmp bx, 0
	je fin2
	jmp devam2

fin2:

	loop COUNT2
ret
delayfunction endp







LoadShiftRegister proc

mov  index, 7h

send_data_to_shift_register:


mov ch, 0
mov cl,  index

mov ah, 0
mov al, data_to_be_stored

shr ax, cl

DATA_PIN equ 1
DATA_CLK equ 0
DATA_STR equ 2

and ax, 1h
cmp ax, 1
je bir 

and PORTA_data, 253
jmp temp1

bir:
or PORTA_data, 2h

temp1: ; shift_register_data = data 

mov al, PORTA_data ; data is put into PA1
out 0, al

or al, 1 ; CLK = 1
out 0, al
nop
nop
nop
nop

and al, 254 ; CLK = 0 
out 0, al
nop
nop
nop
nop

dec index
cmp index, -1
je store
jmp send_data_to_shift_register


store: 
or PORTA_data, 4 ; STR= 1
mov al, PORTA_data
out 0 ,al

nop
nop
nop
nop
and PORTA_data, 251
mov al, PORTA_data
out 0, al

nop
nop




ret
LoadShiftRegister endp

sil equ 1h
basla equ 2h
sola equ 4h
saga equ 6h
kapat equ 8h
imlec_yok equ 0Ch
imlec_var equ 0Fh
imlec_sola equ 10h
imlec_saga equ 14h
display_sola equ 18h
display_saga equ 1Ch
satir_1 equ 80h
satir_2 equ 0C0h
cift_4bit equ 28h
cift_8bit equ 38h
tek_4bit equ 3Ch
tek_8bit equ 30h

shift_reg_set_pin_lcd proc

mov cl, shift_reg_pin_to_set
mov bx, 1

shl bx, cl

cmp reg_pin_value, 1h
je bir_set
not bl
and data_to_be_stored, bl
jmp call_load

bir_set:
or data_to_be_stored, bl

call_load:
call LoadShiftRegister

ret
shift_reg_set_pin_lcd endp 


RS equ 1
E equ 2
DATA_INFO equ 1
COMMAND_INFO equ 2

;no parameters...
LCD_init proc ; parameters 
	
	mov shift_reg_pin_to_set , RS ; RS = 0
	mov reg_pin_value, 0
	call shift_reg_set_pin_lcd

	mov shift_reg_pin_to_set , E; E = 0
	mov reg_pin_value, 0
	call shift_reg_set_pin_lcd
	

	mov command, basla
	mov data_type, COMMAND_INFO
	call lcd_info
	
	mov cx, 590 ; loop lasts when branch is taken 17 cycles, not taken 5 cycles  ~ 10 ms
	ten:
	loop ten

	mov command, cift_4bit
	mov data_type, COMMAND_INFO
	call lcd_info

	mov cx, 590 ;  loop lasts when branch is taken 17 cycles, not taken 5 cycles ~10 ms
	ten2:
	loop ten2

	mov command, saga
	mov data_type, COMMAND_INFO
	call lcd_info

	mov command, imlec_yok
	mov data_type, COMMAND_INFO
	call lcd_info

	call lcd_clear

	mov command, satir_1
	mov data_type, COMMAND_INFO
	call lcd_info



ret 

; parameter data_to_print
lcd_yaz proc
	mov al, data_to_print
	mov command, al
	mov data_type, DATA_INFO
	call lcd_info

	add _x, 1
	cmp _x, 17
	je on_yedi
	jmp no_increase


	on_yedi:
	mov _x, 1
	inc _y
	cmp _y, 3
	je y_uc
	jmp relocate
	
	y_uc:
	mov _y, 1

	relocate:
	call lcd_goto

	
no_increase:
	

ret
lcd_yaz endp

LCD_init endp

; _x, _y  are parameters
lcd_goto PROC

mov al, _x
sub al, 1h

cmp _y, 1h
je satir_bir

add al, satir_2
jmp set_curs

satir_bir:
add al, satir_1

set_curs:
	mov command, al
	mov data_type, COMMAND_INFO
	call lcd_info
ret 
lcd_goto ENDP

; writes a string array to lcd...
; si points to array location in memory
lcd_write PROC

yazdir:
	mov bl, byte ptr[si]
	cmp bl, 0h
	je null_char
	mov bl, byte ptr [si]
	mov data_to_print, bl
	call lcd_yaz
	inc si
	jmp yazdir


	null_char:

	ret
lcd_write ENDP


lcd_clear proc

	mov command, sil
	mov data_type, COMMAND_INFO
	call lcd_info

	mov _x, 1
	mov _y, 1
	call lcd_goto

ret
lcd_clear endp



; parameters command, data_type 
lcd_info proc 
	cmp data_type, COMMAND_INFO ; if datatype == COMAMND_INFO set_pin(RS, 0) else set_pin(RS,1)
	je sifirla_call
	mov reg_pin_value, 1

	jmp set_RS

	sifirla_call:
	mov reg_pin_value, 0

	set_RS:
	mov shift_reg_pin_to_set , RS; RS = 0 | 1
	call shift_reg_set_pin_lcd
	
	mov shift_reg_pin_to_set , E; E = 1
	mov reg_pin_value, 1
	call shift_reg_set_pin_lcd	

	mov bl, command
	and bl, 0f0h
	shr bl, 1

	and data_to_be_stored, 87h
	or data_to_be_stored, bl
	call LoadShiftRegister

	mov cx, 240 ; loop lasts when branch is taken 17 cycles, not taken 5 cycles ~ DELAY 4 ms
	say:
	loop say

	mov shift_reg_pin_to_set , E; E = 0
	mov reg_pin_value, 0
	call shift_reg_set_pin_lcd	

	mov cx, 240 ; loop lasts when branch is taken 17 cycles, not taken 5 cycles ~ DELAY 4 ms
	say1:
	nop
	loop say1

	mov shift_reg_pin_to_set , E; E = 1
	mov reg_pin_value, 1
	call shift_reg_set_pin_lcd

	mov bl, command
	and bl, 0fh
	mov al, bl
	mov ah, 0h
	mov cl, 3h
	shl ax, cl
	mov bl, al


	and data_to_be_stored, 87h
	or data_to_be_stored, bl
	call LoadShiftRegister

	mov cx, 240 ; loop lasts when branch is taken 17 cycles, not taken 5 cycles ~ DELAY 4 ms
	say2:
	loop say2

	mov shift_reg_pin_to_set , E; E = 0
	mov reg_pin_value, 0
	call shift_reg_set_pin_lcd
	
	mov cx, 590 ; loop lasts when branch is taken 17 cycles, not taken 5 cycles ~ DELAY 10 ms
	say3:
	loop say3

ret 
lcd_info endp


CODE    ENDS
        END START


