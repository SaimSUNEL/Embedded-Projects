;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Paz Mar 15 2020
; Processor: 8086
; Compiler:  MASM32
;
; Before starting simulation set Internal Memory Size 
; in the 8086 model properties to 0x10000
;====================================================================

DATA SEGMENT  ; data segment of the program...
PORTC47_pins db 0

DATA ENDS
CODE    SEGMENT PUBLIC 'CODE' 
        ASSUME CS:CODE, DS: DATA


;A16-A19 are not involved in port operations...
; first port is latched in 74hc373 (8086 first outputs port address on data/address bus)
; then this select the port to write, then 8086 sends data to 8255A


; important : data with even numbered addresses are sent over AD0-AD7, odd numbered are over AD8-AD15
; 
; A0 and A1 are connected in a specific way to make the addresses even numbered...
; that's whay Q1 and Q2 is used to select port of 8255a, 
; if it were Q0, Q1 we would use odd addreess number
; 
; Datasheet :
;Physically, the memory is organized as a high bank
;(D15–D8) and a low bank (D7–D0) of 512K 8-bit
;bytes addressed in parallel by the processor’s address lines A19–A1. Byte data with even addresses
;is transferred on the D7–D0 bus lines while odd addressed byte data (A0 HIGH) is transferred on the
;D15–D8 bus lines.
;
;
START:
	mov AX, 100h
	mov SS, AX ; set stack segment
	mov ax, 800h
	mov DS, ax
	mov ax, 0d00h
	mov es, ax
	mov sp , ax ; don't forget to set it...
 
push AX

	mov ah, 0
	mov al, 80h ; PORT A , PORT B ,PORT C 0-3 are outputs, PORTC 4-7 are inputs...
	out 06, al ; control reg  address 
	
	mov al, 0 ; clean all ports, Port A=B=C= 0
	out 0, al
	out 2, al
	out 4, al
	


ENDLESS:
		
mov ah, 0
mov dx, 0
	mov al, 02h ; PORT A = 255
	out 0, al 
	out 2, al

	out 4, al

	in al, 4 ; read PORTC and store value to al
	mov PORTC47_pins, al ; store al in memory...
	
	
	call delayfunction

	mov al, 0h ; PORT A = 0
	out 0, al
	out 2, al

	out 4, al

	in al, 4 ; reread PORTC to al
	mov PORTC47_pins, al ; store value in memory...
	
call delayfunction

		
	JMP ENDLESS


delayfunction proc far


mov cx, 02ffh

	COUNT2:
	mov bx, 01fh


devam2:
	dec bx

	cmp bx, 0
	je fin2
	jmp devam2

fin2:

	loop COUNT2
ret
delayfunction endp
CODE    ENDS
        END START